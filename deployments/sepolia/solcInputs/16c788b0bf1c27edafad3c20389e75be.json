{
  "language": "Solidity",
  "sources": {
    "contracts/lottery.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.8.7;\nerror lottery__NotEnoughEth();\nerror Lottery_TransferFailed();\nerror lottery__notOpen();\nerror  lottery__notEnoughToken();\nerror lottery__notnewBie();\nerror lottery__newBie();\nerror lottery__notEnoughLotterytime();\nerror lottery__notOwner();\n/**\n * @title a sample lottery contract\n * @author helloiampratyush\n * @notice this contract is for creating  untamperable decentralized smart contract\n */\n\n//one of the player should be paid\n\ncontract RandomLottery {\n    address private randomAddress;\n    enum lotteryState {\n        OPEN,\n     CLOSED\n    }\n    struct lotteryThings\n    {\n         uint256 s_entranceFee;\n         uint256 s_latestTimeStamp;\n         uint256 s_interval;\n         lotteryState s_lotteryState;\n         uint256 MinPlayers;\n    }\n    struct login{\n        uint256 streak;\n        uint256 s_lastTimeStamp;\n        uint256 check_reset;\n    }\n\n    // uint256 0=OPEN,uint256 1=CALCULATING\n    //state variable\n    uint256 private lotteryCounter=1;\n    uint256 private lotteryCompletionOwnerTime=0;\n \n    //lottery variable\n    address payable i_owner;\n    address private s_recentWinner;\n   //mapping (uint256=>uint256) private WinnerIndex;\n   mapping(uint256=>lotteryThings) private lotteryMap;\n   mapping(uint256=>address payable[] ) private  s_players;\n   mapping(address=>uint256) private tokenBalance;\n   mapping(address=>login) private loginManagement;\n    //events\n    event lotteryAnnounceMent(uint256 counterNo,uint256 entranceFee,uint256 timeStamp,uint256 endTime,uint256 indexed minplayers);\n    //event enterlottery(uint256 counterNo,address participants,uint256 time);\n    //event RequestedLotteryWinner(uint256 indexed requestId,uint256 lotteryCounter);\n    event winnerPicked(address indexed winner,uint256 lotteryCounter);\n    event lotteryForceEnded(uint256 lotteryCounter);\n   \n    //consructor\n    constructor(){\n        i_owner=payable(msg.sender);\n    }\n \n         \n       function lotteryStart(uint16 _timeInterval,uint256 _entranceFee,uint256 _minplayers) public \n       {\n        if(msg.sender!=i_owner)\n\n        {\n            revert lottery__notOwner();\n        }\n       lotteryMap[lotteryCounter]=lotteryThings(_entranceFee,block.timestamp,_timeInterval,lotteryState.OPEN,_minplayers);\n     \n       emit lotteryAnnounceMent(lotteryCounter,_entranceFee,block.timestamp, block.timestamp+_timeInterval,_minplayers);\n\n         lotteryCounter+=1;\n\n       }\n    function enterLottery(uint256 _lotteryCounter) public payable {\n        if (msg.value < lotteryMap[_lotteryCounter].s_entranceFee) {\n            revert lottery__NotEnoughEth();\n        }\n        if (lotteryMap[_lotteryCounter].s_lotteryState != lotteryState.OPEN) {\n            revert lottery__notOpen();\n        }\n       if(block.timestamp>lotteryMap[_lotteryCounter].s_latestTimeStamp+lotteryMap[_lotteryCounter].s_interval){\n        revert lottery__notOpen();\n       }\n        s_players[_lotteryCounter].push(payable(msg.sender));\n        randomAddress=msg.sender;\n     \n    }\n//condition checking variable\n   function checkThings(uint256 _lotteryCounter) public view returns(bool) \n   {\n    bool isDeadinePassed=(block.timestamp>=(lotteryMap[_lotteryCounter].s_latestTimeStamp+lotteryMap[_lotteryCounter].s_interval));\n    bool isPlayerAll=(s_players[_lotteryCounter].length>=lotteryMap[_lotteryCounter].MinPlayers);\n    bool islotteryStillOn=checkLotteryStatus(_lotteryCounter);\n    bool res=(isDeadinePassed&&isPlayerAll&&islotteryStillOn);\n    return res;\n    \n   }\n    //winnerPicking\n\n        function makeThingsWinner(uint256 _lotteryCounter) public  {\n           \n            require(checkThings(_lotteryCounter)==true,\"you cant enter here\");\n            require(msg.sender==i_owner,\"owner have given privillages due to security issues\");\n             uint256 indexofWinner;\n\n           if(checkThings(_lotteryCounter)){\n            indexofWinner=uint256(keccak256(abi.encodePacked(randomAddress,block.number,s_players[_lotteryCounter].length)))%(s_players[_lotteryCounter].length);  \n              \n           }\n           address payable recentWinner= payable (s_players[_lotteryCounter][indexofWinner]);\n             uint256 amount=(4*(s_players[_lotteryCounter].length)*(lotteryMap[_lotteryCounter].s_entranceFee))/5;\n              lotteryMap[_lotteryCounter].s_lotteryState=lotteryState.CLOSED;\n             (bool success, ) = recentWinner.call{value: amount}(\"\");\n             require(success,\"transaction Failed\");\n            \n             //token distribution\n            for(uint256 i=0;i<s_players[_lotteryCounter].length;i++){\n                address participants=s_players[_lotteryCounter][i];\n                tokenBalance[participants]+=4;\n\n             }\n             delete s_players[_lotteryCounter];\n             lotteryCompletionOwnerTime+=1;\n             emit winnerPicked(recentWinner,_lotteryCounter);\n        }\n           //token exchanging\nfunction exchangeTokenToeth() public returns(bool){\n    if(getTokenBalance()<100){\n        revert lottery__notEnoughToken();\n    }\n    require(address(this).balance>=0.1*1e18,\"can not exchange now,low contract balance \");\n    require(getOverAllLotteryStatus(),\"all lottery should be in closed state\");\n      tokenBalance[msg.sender]-=100;\n      (bool success,)=(msg.sender).call{value:0.1*1e18}(\"\");\n      require(success,\"transaction Failed\");\n      return true;\n      }\n    function newBieBonus() public {\n    \n        if(loginManagement[msg.sender].check_reset==0){\n            loginManagement[msg.sender]=login(1,block.timestamp,1);\n            tokenBalance[msg.sender]+=5;\n\n        }\n        else {\n                revert lottery__notnewBie(); \n        }\n    }\n    //login token distribution\n    function loginManagement1() public {\n          require(loginManagement[msg.sender].check_reset>0,\"you are new bie\");\n          require((block.timestamp)-(loginManagement[msg.sender].s_lastTimeStamp)>=(24*3600),\"not 24 hours past\");\n           if(block.timestamp-(loginManagement[msg.sender].s_lastTimeStamp)>(2*24*3600)){\n                       loginManagement[msg.sender].streak=1;\n                     \n                       loginManagement[msg.sender].s_lastTimeStamp=block.timestamp;\n                       tokenBalance[msg.sender]+=1;\n           }\n           else {\n            uint256 streakDay=loginManagement[msg.sender].streak;\n                 if(streakDay>=1&&streakDay<6){\n                     loginManagement[msg.sender].streak+=1;\n                \n                       loginManagement[msg.sender].s_lastTimeStamp=block.timestamp;\n                       tokenBalance[msg.sender]+=1;\n                 }\n                 else{\n                     loginManagement[msg.sender].streak+=1;\n                    \n                       loginManagement[msg.sender].s_lastTimeStamp=block.timestamp;\n                       tokenBalance[msg.sender]+=2;\n                 }\n           }\n    }\n    //owner cashout\n    function ownerCashout() public {\n        require(msg.sender==i_owner,\"you are not eligible for commercial fund\");\n         require(getOverAllLotteryStatus(),\"all lottery should be in closed state\");\n        if(lotteryCompletionOwnerTime>10){\n             require(address(this).balance>=0.8*1e18,\"sorry you can not cash out now,low balance\");\n                         lotteryCompletionOwnerTime-=10;\n        (bool success,)= i_owner.call{value:0.8*1e18}(\"\");\n      require(success,\"transaction failed\");\n      \n        }\n        else {\n            revert lottery__notEnoughLotterytime();\n        }       \n    }\n    //some getter\n    \n        \n    \n    function getOverAllLotteryStatus() public view returns(bool){\n        bool totalStatus=true;\n        for(uint256 i=1;i<=lotteryCounter;i++){\n            bool status=(lotteryMap[i].s_lotteryState==lotteryState.CLOSED);\n            totalStatus=totalStatus&&status;\n        }\n        return totalStatus;\n    }\n    //refund function\n    function getYourRefund(uint256 _lotteryCounter) public {\n        uint256 lotteryEnded=lotteryMap[_lotteryCounter].s_interval+lotteryMap[_lotteryCounter].s_latestTimeStamp;\n        require(block.timestamp-lotteryEnded>3600*24,\"wait for sometime\");\n        bool varCheck=false;\n        uint256 counter;\n        for(uint256 i=0;i<s_players[_lotteryCounter].length;i++){\n            if(s_players[_lotteryCounter][i]==msg.sender){\n                counter=i;\n                varCheck=true;\n            }\n        }\n        require(varCheck==true,\"you are not in this list\");\n        uint256 getRefund=lotteryMap[_lotteryCounter].s_entranceFee;\n        delete s_players[_lotteryCounter][counter];\n          (bool success,)=(msg.sender).call{value:getRefund}(\"\");\n          require(success,\"transaction failed\");\n        \n         if(s_players[_lotteryCounter].length==0){\n            lotteryMap[_lotteryCounter].s_lotteryState=lotteryState.CLOSED;\n\n         }\n    }\n    //still refund is active\n    function forceLotteryClosed(uint256 _lotteryCounter) public {\n\n             require(msg.sender==i_owner,\"owner required for shutdown lottery\");\n             uint256 lotteryEnded=lotteryMap[_lotteryCounter].s_interval+lotteryMap[_lotteryCounter].s_latestTimeStamp;\n              require(block.timestamp-lotteryEnded>3600*24*2,\"wait for sometime\");\n    lotteryMap[_lotteryCounter].s_lotteryState=lotteryState.CLOSED;\n    emit lotteryForceEnded(_lotteryCounter);\n\n    }\n   function getYourStreak() public view returns(uint256){\n    return(loginManagement[msg.sender].streak);\n   }      \n    function getTokenBalance() public view returns(uint256){\n        return (tokenBalance[msg.sender]);\n    }\n   \n     function minplayerRequiredToJoin(uint256 _lotteryCounter) public view returns(uint256){\n        require((lotteryMap[_lotteryCounter].MinPlayers-s_players[_lotteryCounter].length)>0);\n        return (lotteryMap[_lotteryCounter].MinPlayers-s_players[_lotteryCounter].length);\n     }\n    function checkLotteryStatus(uint256 _lotteryCounter) public view returns(bool){\n        return(lotteryMap[_lotteryCounter].s_lotteryState==lotteryState.OPEN);\n    }\n    function getlatestLoginTime() public view returns(uint256){\n        return (loginManagement[msg.sender].s_lastTimeStamp);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}